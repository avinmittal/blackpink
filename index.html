<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Birthday Aadya</title>

<link rel="preconnect" href="https://www.youtube.com">
<link rel="preconnect" href="https://www.youtube-nocookie.com">
<link rel="preconnect" href="https://www.google.com">
<link rel="preconnect" href="https://i.ytimg.com">

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #000;
  height: 100%;
  overflow: hidden;
}
#player {
  width: 100%;
  height: 100%;
}

/* Tiny "beat flash" only for cross-video cuts (optional mask) */
#flash {
  position: fixed;
  inset: 0;
  background: rgba(255,255,255,0.12);
  opacity: 0;
  pointer-events: none;
  transition: opacity 40ms linear;
  z-index: 20;
}
#flash.on { opacity: 1; }
</style>
</head>
<body>

<div id="player"></div>
<div id="flash"></div>

<script>
/* =========================
   SEGMENTS (in order)
   ========================= */
const segments = [
  { videoId: "IHNzOHi8sJs", start: 0,  end: 24 },
  { videoId: "IHNzOHi8sJs", start: 66, end: 94 },
  { videoId: "2S24-y0Ij3Y", start: 59, end: 92 },
  { videoId: "bwmSjveL3Lc", start: 0,  end: 55 },
  { videoId: "bwmSjveL3Lc", start: 82, end: 113 }
];

/* =========================
   TUNING
   - Tighten ONLY same-video cuts
   ========================= */
const END_MARGIN_SAME_SEC = 0.03;     // 30ms before end for same-video jumps
const END_MARGIN_XVID_SEC = 0.10;     // keep cross-video looser (avoid overshoot)
const NEAR_END_WINDOW_SEC = 0.60;     // enter aggressive mode this close to end
const POLL_NEAR_END_MS = 25;          // iPhone 17 optimization (more CPU, tighter)

/* =========================
   STATE
   ========================= */
let player = null;
let playerReady = false;
let started = false;

let segIndex = 0;

// Monitoring handles
let monitoring = false;
let rafId = null;
let nearEndIntervalId = null;

const flashEl = document.getElementById("flash");
function flash() {
  flashEl.classList.add("on");
  setTimeout(() => flashEl.classList.remove("on"), 60);
}

/* =========================
   YT IFrame API load
   ========================= */
const tag = document.createElement("script");
tag.src = "https://www.youtube.com/iframe_api";
document.head.appendChild(tag);

window.onYouTubeIframeAPIReady = () => {
  player = new YT.Player("player", {
    // Using nocookie host is fine, but it can affect login cookies in some cases.
    // If your Premium login works best with the normal host, leave host unset.
    // host: "https://www.youtube-nocookie.com",
    videoId: segments[0].videoId,
    playerVars: {
      playsinline: 1,
      controls: 1,            // manual play/pause
      rel: 0,
      modestbranding: 1,
      origin: window.location.origin
    },
    events: {
      onReady: () => { playerReady = true; },
      onStateChange
    }
  });
};

function onStateChange(e) {
  if (e.data === YT.PlayerState.PLAYING) startMonitoring();
  if (e.data === YT.PlayerState.PAUSED ||
      e.data === YT.PlayerState.ENDED ||
      e.data === YT.PlayerState.BUFFERING) {
    stopMonitoring();
  }
}

/* =========================
   Helpers
   ========================= */
function safeTime() {
  try { return player.getCurrentTime() || 0; } catch { return 0; }
}

function currentVideoId() {
  try { return player.getVideoData().video_id || ""; } catch { return ""; }
}

function isSameVideo(nextIdx) {
  const cur = segments[segIndex];
  const nxt = segments[nextIdx];
  return cur && nxt && cur.videoId === nxt.videoId;
}

/* =========================
   Monitoring (two-phase)
   - rAF always
   - near-end aggressive setInterval only for same-video next cut
   ========================= */
function stopMonitoring() {
  monitoring = false;
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  if (nearEndIntervalId) clearInterval(nearEndIntervalId);
  nearEndIntervalId = null;
}

function startMonitoring() {
  if (monitoring) return;
  monitoring = true;

  const check = () => {
    if (!monitoring) return;

    const s = segments[segIndex];
    const t = safeTime();
    const nextIdx = segIndex + 1;

    const sameNext = (nextIdx < segments.length) && isSameVideo(nextIdx);
    const margin = sameNext ? END_MARGIN_SAME_SEC : END_MARGIN_XVID_SEC;

    // Cut point
    if (t >= s.end - margin) {
      nextSegment();
      return;
    }

    // Aggressive polling near end ONLY if next is same-video
    if (sameNext && nearEndIntervalId === null && (s.end - t) <= NEAR_END_WINDOW_SEC) {
      nearEndIntervalId = setInterval(() => {
        if (!monitoring) return;
        const tt = safeTime();
        if (tt >= s.end - END_MARGIN_SAME_SEC) nextSegment();
      }, POLL_NEAR_END_MS);
    }

    rafId = requestAnimationFrame(check);
  };

  rafId = requestAnimationFrame(check);
}

/* =========================
   Playback
   ========================= */
function playSegment(i) {
  segIndex = i;
  const s = segments[segIndex];
  stopMonitoring();

  const curId = currentVideoId();

  // Same-video jumps are the tightest/fastest
  if (curId && curId === s.videoId) {
    try {
      player.seekTo(s.start, true);
      player.playVideo();
      return;
    } catch {}
  }

  // Cross-video: unavoidable load gap (optional tiny flash to mask)
  flash();
  player.loadVideoById({ videoId: s.videoId, startSeconds: s.start });
}

function nextSegment() {
  stopMonitoring();
  const next = segIndex + 1;
  if (next >= segments.length) return;
  playSegment(next);
}

/* =========================
   Fullscreen "sticky" on iPhone Chrome:
   - request fullscreen on the iframe when user taps
   - try to re-enter if it drops
   ========================= */
function enterFullscreen() {
  const iframe = document.querySelector("iframe");
  if (!iframe) return;
  if (iframe.requestFullscreen) iframe.requestFullscreen();
  else if (iframe.webkitRequestFullscreen) iframe.webkitRequestFullscreen();
}

function keepFullscreen() {
  if (!document.fullscreenElement) enterFullscreen();
}
document.addEventListener("fullscreenchange", keepFullscreen);

/* =========================
   Start (one tap)
   ========================= */
function startPlayback() {
  if (started || !playerReady) return;
  started = true;

  enterFullscreen();
  playSegment(0);
}

document.addEventListener("click", startPlayback, { once: true });
document.addEventListener("touchstart", startPlayback, { once: true });
</script>

</body>
</html>
